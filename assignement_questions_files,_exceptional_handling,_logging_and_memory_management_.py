# -*- coding: utf-8 -*-
"""Assignement Questions Files, exceptional handling, logging and memory management .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12OXqZfsdN8h3OvatCCmu8dxEc3ODdI8V

**Assignment Questions**

Q1.What is the difference between interpreted and compiled languages ?

- The difference between interpreted and compiled languages lies in how their source code is translated into machine code (which the computer can execute).

1. Compiled Language

- The entire program is translated into machine code before execution by a compiler.
- Faster — since code is already compiled into machine code.
- Errors are detected at compile time (before running the program).
- Produces an executable file (e.g., .exe file in C/C++).

2. Interpreted Language
- The program is translated line by line during execution by an interpreter.
- Slower — each line is interpreted at runtime.
- Errors are detected at runtime (when the specific line executes).
- Does not produce a separate executable file.

Q2. What is exception handling in Python ?

- Exception handling in Python is a mechanism that allows you to detect and handle runtime errors (called exceptions) so that the normal flow of the program is not interrupted.

- When an error occurs during execution, Python raises an exception. If that exception is not handled, the program will crash.
Exception handling ensures that you can respond to errors gracefully instead of stopping abruptly.

Q3.What is the purpose of the finally block in exception handling ?

- The finally block in Python is used to define code that must execute no matter what happens — whether an exception occurs or not.

- It is typically used for cleanup operations, such as closing files, releasing resources, or disconnecting from databases, to ensure they happen even if an error interrupts normal program flow.

Q4. What is logging in Python ?

- Logging in Python is the process of recording (or logging) messages that describe events that occur while a program is running.

- It helps track the flow of execution, debug issues, and monitor system behavior — especially in large applications.

Q5. What is the significance of the __del__ method in Python ?

- The __del__() method in Python is a special method known as the destructor. It is automatically called by Python’s garbage collector when an object is about to be destroyed or removed from memory. The main purpose of this method is to perform cleanup operations before the object is deleted.
- This method is mainly used to release external resources such as closing files, database connections, network sockets, or freeing memory that was allocated during the lifetime of the object. It helps in resource de-allocation, ensuring that no unused resources remain after the object is destroyed.
- However, the __del__() method is not completely reliable because the exact time of its execution is controlled by the garbage collector. In some cases, such as when circular references exist or when the program is closed forcefully, the __del__() method might not be executed. Due to this limitation, Python generally recommends using context managers (with statement) for reliable resource management instead of depending only on __del__().

Q6. What is the difference between import and from ... import in Python ?

- The import statement imports the entire module as a single object. To access any function, variable, or class from that module, the module name must be used as a prefix. This makes the source of the function clear and avoids naming conflicts between functions of different modules. However, this approach may consume slightly more memory because the complete module is loaded.

- The from … import statement imports specific functions, variables, or classes directly into the current namespace. After importing, these members can be used without the module name. This makes the code shorter and easier to write, but it may lead to name conflicts if two imported modules contain members with the same name.

Q7.  How can you handle multiple exceptions in Python ?

- In Python, multiple exceptions can be handled using more than one except block or by grouping several exceptions together in a single except statement. This allows a program to respond correctly to different types of runtime errors without terminating abruptly and improves the reliability of the program.

- The most common way is to write multiple except blocks after one try block. Each except block is used to handle a specific type of exception. When an error occurs in the try block, Python checks each except block in order and executes the one that matches the raised exception.

Q8. What is the purpose of the with statement when handling files in Python ?

- The with statement in Python is used to simplify file handling and to ensure proper management of system resources such as file objects. It works on the principle of context management, which means it automatically takes care of opening and closing a file during program execution.

- When a file is opened using the with statement, Python guarantees that the file will be closed automatically as soon as the control leaves the with block, even if an exception occurs while reading or writing the file. This makes file handling safer and helps prevent resource leaks that can occur if files are not properly closed.

- Without the with statement, a programmer must manually write file.close() after performing file operations. If the program crashes or an error occurs before calling close(), the file may remain open, leading to memory wastage or data corruption. The with statement removes this risk by handling cleanup automatically.

Q9.  What is the difference between multithreading and multiprocessing ?

- Multithreading and multiprocessing are two important techniques used to achieve parallelism and concurrency in a program. Although both aim to improve performance and efficiency by executing tasks simultaneously, they work in different ways and are used in different situations.

- Multithreading means running multiple threads within a single process. All threads share the same memory space and resources of the process. It is mainly used for I/O-bound tasks, such as file handling, network communication, or user interface operations. Since threads share memory, communication between them is easier, but this can also lead to problems like race conditions and data inconsistency if not handled carefully. Threads are lightweight and are created faster than processes.

- Multiprocessing, on the other hand, means running multiple independent processes simultaneously. Each process has its own memory space, so they do not share data directly. It is mainly used for CPU-bound tasks, such as heavy mathematical computations, data analysis, and machine learning. Because each process has its own memory, it avoids data conflicts, but communication between processes is slower and more complex. Creating processes requires more system resources compared to threads.

Q10. What are the advantages of using logging in a program ?

- Logging is the process of recording events, messages, and errors that occur while a program is running. It is an essential practice in software development because it helps developers understand the program’s behavior and diagnose problems efficiently.

- Key Advantages:

1. Helps in Debugging Problems
Logging provides detailed information about errors and program flow. When a bug occurs, the log messages help developers find where and why the problem happened without manually checking every line of code.

2. Improves Monitoring and Performance Analysis
Developers and system administrators can monitor the performance of an application (CPU usage, memory usage, response time) using logs. This helps in identifying slow or inefficient parts of the program.

3. Better Error Tracking than Print Statements
Unlike simple print() statements, logging allows setting different levels such as:

DEBUG

INFO

WARNING

ERROR

CRITICAL
This makes it easy to control what type of messages should be recorded.

4. Permanent Record for Future Reference
Log messages can be saved in files. This provides a permanent record of events that occurred in the application, which is very useful for later analysis or audits.

5. Useful in Large Applications and Production Systems
In real-world, large-scale applications, logging is the best way to track system activity without interrupting the user. It supports better maintenance and system reliability.

Q11. What is memory management in Python ?

- Memory management in Python refers to the process of efficiently allocating, using, and freeing memory for objects during program execution. Since Python is a high-level, dynamically typed language, it automatically handles memory allocation and deallocation for objects, which helps developers focus on coding rather than manual memory handling.

Q12. What are the basic steps involved in exception handling in Python ?

- Exception handling in Python is used to detect and handle runtime errors so that the program does not crash. It allows developers to respond to errors gracefully and maintain normal program execution.

Basic Steps -:

1. try – write code that may fail,

2. except – handle exceptions,

3. else – execute if no exception occurs,

4. finally – execute cleanup code.

Q13. Why is memory management important in Python  ?

- Memory management in Python is crucial because it ensures efficient use of system resources, prevents memory leaks, and maintains the performance and stability of applications. Since Python programs often create and destroy many objects dynamically, proper memory management is essential for reliable execution.

14.  What is the role of try and except in exception handling ?

->   try Block

- The try block contains the code that might raise an exception during execution.

- Python executes the statements inside the try block normally until an exception occurs.

- If no exception occurs, the program continues to the next block of code.

- If an exception occurs, Python stops executing the try block and looks for a matching except block.

->  except Block

- The except block is used to handle exceptions raised in the try block.

- It catches the exception and executes alternative code to prevent the program from terminating abruptly.

- Specific exception types can be caught (e.g., ZeroDivisionError, ValueError) or a general exception can be caught using Exception.

Q15. How does Python's garbage collection system work ?
- Python’s garbage collection system is responsible for automatic memory management, ensuring that objects that are no longer in use are properly deallocated to free memory and prevent memory leaks. Python combines reference counting with a cyclic garbage collector to manage memory efficiently.

Q16. What is the purpose of the else block in exception handling ?

- In Python, the else block in exception handling is an optional part of the try-except construct. It is executed only if no exception occurs in the try block. This allows you to separate the normal execution code from the exception handling code, improving readability and structure.

Q17. What are the common logging levels in Python ?

- Python’s logging module provides a flexible framework to record messages with different severity levels. Logging levels help developers categorize events in a program and control which messages are displayed or saved.
- COMMON LOGGING LEVELS
| Level        | Numeric Value | Description                                                                              |
| ------------ | ------------- | ---------------------------------------------------------------------------------------- |
| **DEBUG**    | 10            | Detailed information for diagnosing problems. Used during development.                   |
| **INFO**     | 20            | General information about program execution, such as progress or status updates.         |
| **WARNING**  | 30            | Indicates a potential problem or unexpected situation that does not stop the program.    |
| **ERROR**    | 40            | Represents serious issues that prevent a part of the program from functioning correctly. |
| **CRITICAL** | 50            | Very severe errors that may cause the program to terminate.                              |

Q18. What is the difference between os.fork() and multiprocessing in Python ?

- 1. os.fork()

- os.fork() is a low-level system call available on Unix/Linux systems.

- It creates a child process that is an exact copy of the parent process, including memory space.

- The child process shares the same code but has its own memory after the fork.

- os.fork() is not available on Windows.

- Requires careful handling of shared resources, as it is low-level.

2. multiprocessing Module

- multiprocessing is a high-level Python module for creating and managing processes.

- It works on all major platforms, including Windows and Unix/Linux.

- Provides features like process pools, queues, pipes, and shared variables for inter-process communication.

- Easier to write, manage, and synchronize multiple processes compared to os.fork().

- Each process runs in its own memory space, but communication tools allow data sharing safely.

Q19. What is the importance of closing a file in Python ?

- In Python, it is important to close a file after performing file operations (reading, writing, or appending) to ensure proper resource management and avoid potential issues. When a file is opened, the operating system allocates resources (like memory and file handles) to manage it. Closing the file releases these resources and ensures the program works correctly.

20. What is the difference between file.read() and file.readline() in Python ?

 -> file.read()

- Reads the entire content of the file (or a specified number of characters) as a single string.

- If no argument is provided, it reads all data from the current position to the end of the file.

- Suitable when you want to process the whole file at once.

-> file.readline()

- Reads one line at a time from the file.

- Each call to readline() returns the next line as a string, including the newline character \n.

- Useful for processing files line by line to save memory for large files.

Q21. What is the logging module in Python used for ?

- The logging module in Python is a built-in module used to record and track events that occur during the execution of a program. It helps developers understand what is happening inside an application at different stages and is mainly used for debugging, monitoring, and maintaining software systems.

Instead of using print() statements, the logging module provides a flexible, configurable, and robust way to generate log messages. These messages can be written to the console, files, or remote servers and can be formatted as required.

Q22.What is the os module in Python used for in file handling ?

- The os module in Python is used to interact with the operating system for performing various file and directory operations. In file handling, it provides functions to create, delete, rename, move, and manage files and folders directly from a Python program.

Q23. What are the challenges associated with memory management in Python ?
- Python handles most of its memory management automatically, but developers still face several important challenges, especially when building large or long-running applications.

- Major challenges in Python memory management:

1. Memory Leaks
- Although Python has garbage collection, memory leaks can still occur due to unnecessary object references, global variables, or objects stored in data structures and never released.

2. Circular References
- When two or more objects reference each other, it creates a reference cycle. These objects may not be freed immediately by reference counting, increasing memory usage until the garbage collector handles them.

3. High Memory Consumption
- Python data structures (like lists, dictionaries, and objects) consume more memory than lower-level languages. Large datasets can quickly use up RAM.

4. Delayed Garbage Collection
- Python’s garbage collector does not always run immediately. This can cause unused objects to remain in memory longer than necessary, affecting performance.

5. Fragmentation
- Continuous creation and deletion of objects can lead to memory fragmentation, where free memory is split into small blocks, reducing efficiency.

6. Inefficient Object Handling
- Creating too many temporary objects or copying large objects instead of reusing them can increase memory overhead.

Q24. How do you raise an exception manually in Python ?

- In Python, you can raise an exception manually using the raise keyword. This is done when you want to stop the program or signal an error condition yourself, instead of waiting for Python to raise an error automatically.

Q25. Why is it important to use multithreading in certain applications ?

- Multithreading is important in certain applications because it allows a program to perform multiple tasks at the same time within a single process. This improves the efficiency, speed, and responsiveness of applications.

- Importance of multithreading:

1. Better Performance
- Multiple threads can run in parallel (especially on multi-core processors), which reduces execution time and improves overall performance.

2. Improved Responsiveness
- In applications like GUI programs and web servers, one thread can handle user interaction while others run background tasks, preventing the application from freezing.

3. Efficient Resource Utilization
- Threads share the same memory space, so they use less memory compared to multiple processes.

4. Parallel Task Handling
- Multithreading is useful when tasks can be divided into smaller independent parts, such as downloading multiple files or processing many requests.

5. Better Scalability
- Server applications use multithreading to handle multiple clients at the same time, making the system more scalable.

**Practical** **Questions**

1. How can you open a file for writing in Python and write a string to it.
"""

file = open("example.txt", "w")
file.write("Hello, this is a sample text written to the file.")
file.close()

"""2. Write a Python program to read the contents of a file and print each line."""

with open("example.txt", "r") as file:
    for line in file:
        print(line, end="")

"""3. How would you handle a case where the file doesn't exist while trying to open it for reading ?"""

try:
    with open("example.txt", "r") as file:
        for line in file:
            print(line, end="")

except FileNotFoundError:
    print("Error: The file does not exist.")

except Exception as e:
    print("An unexpected error occurred:", e)

"""4. Write a Python script that reads from one file and writes its content to another file ."""

import os

# Ensure source.txt exists before trying to read from it
if not os.path.exists("source.txt"):
    with open("source.txt", "w") as s_file:
        s_file.write("This is the content of the source file.\nLine 2.\nLine 3.")
    print("Created 'source.txt' with sample content.")

with open("source.txt", "r") as source_file:
    content = source_file.read()

with open("destination.txt", "w") as dest_file:
    dest_file.write(content)

print("File copied successfully!")

"""5.How would you catch and handle division by zero error in Python ?"""

try:
    num1 = int(input("Enter first number: "))
    num2 = int(input("Enter second number: "))

    result = num1 / num2
    print("Result:", result)

except ZeroDivisionError:
    print("Error: Division by zero is not allowed.")

except ValueError:
    print("Error: Please enter valid integers.")

"""6.Write a Python program that logs an error message to a log file when a division by zero exception occurs ?"""

import logging

logging.basicConfig(
    filename="error.log",
    level=logging.ERROR,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

try:
    a = int(input("Enter first number: "))
    b = int(input("Enter second number: "))

    result = a / b
    print("Result:", result)

except ZeroDivisionError:
    logging.error("Division by zero attempted.")
    print("Error: Division by zero is not allowed.")

except ValueError:
    logging.error("Invalid input entered.")
    print("Error: Please enter valid integers.")

"""7. How do you log information at different levels (INFO, ERROR, WARNING) in Python using the logging module ?"""

import logging


logging.basicConfig(
    filename="app.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

logging.info("This is an INFO message")
logging.warning("This is a WARNING message")
logging.error("This is an ERROR message")

"""8. Write a program to handle a file opening error using exception handling ?"""

try:
    file = open("data.txt", "r")
    content = file.read()
    print(content)
    file.close()

except FileNotFoundError:
    print("Error: The file does not exist.")

except PermissionError:
    print("Error: You don't have permission to open this file.")

except Exception as e:
    print("An unexpected error occurred:", e)

"""9. How can you read a file line by line and store its content in a list in Python ?"""

import os

file_name = "data.txt"

if not os.path.exists(file_name):
    with open(file_name, "w") as f:
        f.write("Line 1 of data.\n")
        f.write("Line 2 of data.\n")
        f.write("Line 3 of data.")
    print(f"'{file_name}' created with sample content.")

with open(file_name, "r") as file:
    lines = file.readlines()

print(lines)

"""10. How can you append data to an existing file in Python ?"""

with open("example.txt", "a") as file:
    file.write("This line will be appended to the file.\n")

"""11. Write a Python program that uses a try-except block to handle an error when attempting to access a
dictionary key that doesn't exist ?
"""

my_dict = {"name": "Harsh", "age": 21}

try:

    print("Address:", my_dict["address"])

except KeyError:
    print("Error: The key 'address' does not exist in the dictionary.")

"""12. Write a program that demonstrates using multiple except blocks to handle different types of exceptions ?"""

try:
    num1 = int(input("Enter first number: "))
    num2 = int(input("Enter second number: "))

    result = num1 / num2
    print("Result:", result)

    my_list = [1, 2, 3]
    print(my_list[5])

except ZeroDivisionError:
    print("Error: Division by zero is not allowed.")

except ValueError:
    print("Error: Invalid input! Please enter integers.")

except IndexError:
    print("Error: List index out of range.")

except Exception as e:
    print("An unexpected error occurred:", e)

"""13.  How would you check if a file exists before attempting to read it in Python ?"""

import os

if os.path.exists("example.txt"):
    with open("example.txt", "r") as file:
        print(file.read())
else:
    print("File does not exist.")

"""14. Write a program that uses the logging module to log both informational and error messages ?"""

import logging

logging.basicConfig(
    filename="app.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

logging.info("Program started successfully.")

try:
    num1 = 10
    num2 = 0
    result = num1 / num2
    logging.info(f"Division result: {result}")

except ZeroDivisionError:
    logging.error("Division by zero attempted!")

print("Check 'app.log' for logged messages.")

"""15. Write a Python program that prints the content of a file and handles the case when the file is empty ?"""

try:
    with open("example.txt", "r") as file:
        content = file.read()

        if content:
            print("File content:\n", content)
        else:
            print("The file is empty.")

except FileNotFoundError:
    print("Error: The file does not exist.")

except Exception as e:
    print("An unexpected error occurred:", e)

"""16 Demonstrate how to use memory profiling to check the memory usage of a small program ?"""

pip install memory-profiler

from memory_profiler import profile

@profile
def my_function():
    a = [i for i in range(100000)]
    b = [i**2 for i in range(100000)]
    c = a + b
    return c
my_function()

"""17. Write a Python program to create and write a list of numbers to a file, one number per line ?"""

numbers = [10, 20, 30, 40, 50]

with open("numbers.txt", "w") as file:
    for number in numbers:
        file.write(f"{number}\n")

print("Numbers have been written to numbers.txt")

"""18. How would you implement a basic logging setup that logs to a file with rotation after 1MB ?"""

import logging
from logging.handlers import RotatingFileHandler


handler = RotatingFileHandler(
    "app.log",
    maxBytes=1*1024*1024,
    backupCount=3
)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[handler]
)


logging.info("This is an info message.")
logging.warning("This is a warning message.")
logging.error("This is an error message.")

"""19. Write a program that handles both IndexError and KeyError using a try-except block ?"""

my_list = [1, 2, 3]
my_dict = {"name": "Harsh", "age": 21}

try:

    print("List element:", my_list[5])

    print("Dictionary value:", my_dict["address"])

except IndexError:
    print("Error: List index out of range.")

except KeyError:
    print("Error: Dictionary key does not exist.")

except Exception as e:
    print("An unexpected error occurred:", e)

"""20.How would you open a file and read its contents using a context manager in Python ?"""

with open("example.txt", "r") as file:
    content = file.read()

print(content)

"""21. Write a Python program that reads a file and prints the number of occurrences of a specific word ?"""

word_to_count = "Python"
count = 0

try:
    with open("example.txt", "r") as file:
        for line in file:

            words = line.split()
            count += words.count(word_to_count)

    print(f"The word '{word_to_count}' occurs {count} times in the file.")

except FileNotFoundError:
    print("Error: The file does not exist.")

except Exception as e:
    print("An unexpected error occurred:", e)

"""22. How can you check if a file is empty before attempting to read its contents ?"""

import os

file_path = "example.txt"

if os.stat(file_path).st_size == 0:
    print("The file is empty.")
else:
    with open(file_path, "r") as file:
        print(file.read())

"""23. Write a Python program that writes to a log file when an error occurs during file handling ?"""

import logging

logging.basicConfig(
    filename="file_errors.log",
    level=logging.ERROR,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

try:

    with open("non_existing_file.txt", "r") as file:
        content = file.read()
        print(content)

except FileNotFoundError:
    logging.error("File not found error occurred while trying to open the file.")
    print("Error: File not found.")

except PermissionError:
    logging.error("Permission error occurred while trying to access the file.")
    print("Error: Permission denied.")

except Exception as e:
    logging.error(f"An unexpected error occurred: {e}")
    print("An unexpected error occurred.")

